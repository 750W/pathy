use egui::{Pos2, Vec2};

use std::{cell::RefCell, rc::Rc};

use crate::bezier::Point;

/// Formats a number to a string,
fn format_num(num: f32, precision: usize) -> String {
    format!("{:.1$}", num, precision)
        .trim_end_matches('0')
        .trim_end_matches('.')
        .to_string()
}

/// Generates path code from a path.
pub fn generate(path: &[Rc<RefCell<Point>>], step: f32) -> String {
    if path.len() < 2 {
        return "// Create two points to get started".into();
    }
    // Group into unbroken paths
    let points: Vec<Pos2> = path.iter().map(|p| p.borrow().clone().into()).collect();
    if points.len() < 2 {
        return "// Create two points to get started".into();
    }
    // actually using vectors this time :)
    let vectors: Vec<Vec2> = points.windows(2).map(|w| w[1] - w[0]).collect();
    let mut result: String = "// Generated by Pathy\n\n".into();
    let mut heading = vectors.get(0).unwrap().angle();
    let mut moves: Vec<(f32, Option<f32>)> = vec![(vectors.get(0).unwrap().length(), None)];
    for vector in vectors.iter().skip(1) {
        let length = vector.length();
        let angle = vector.angle();
        let pi = std::f32::consts::PI;
        moves.push((
            length,
            if f32::abs(angle - heading) > f32::to_radians(0.5) {
                Some(-f32::to_degrees(
                    (heading - angle + pi).rem_euclid(2.0 * pi) - pi,
                ))
            } else {
                None
            },
        ));
        heading = angle;
    }
    // now return it all formatted
    for (length, turn) in moves {
        let mut addition = String::new();
        let distance = &format!(
            "chassis.pid_drive_set({}_in, DRIVE_SPEED);\nchassis.pid_wait();\n",
            format_num(length, 2)
        );
        if let Some(angle) = turn {
            addition.push_str(&format!(
                "chassis.pid_turn_set({}_deg, DRIVE_SPEED);\nchassis.pid_wait();",
                format_num(angle, 2)
            ));
        }
        addition.push_str(distance);
        result.push_str(&addition);
    }
    result
}

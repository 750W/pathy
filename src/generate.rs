use wasm_bindgen::convert::IntoWasmAbi;

use crate::bezier::BezPoint;
use std::{cell::RefCell, rc::Rc};

/// Formats a number to a string,
fn format_num(num: f32, precision: usize) -> String {
    format!("{:.1$}", num, precision)
        .trim_end_matches('0')
        .trim_end_matches('.')
        .to_string()
}

/// Generates path code from a path.
pub fn generate(path: &[Rc<RefCell<BezPoint>>], step: f32) -> String {
    if path.len() < 2 {
        return "// Create two points to get started".into();
    }
    // Group into unbroken paths
    let mut paths: Vec<Vec<BezPoint>> = Vec::new();
    paths.push(Vec::new());
    for i in 0..path.len() {
        paths.last_mut().unwrap().push(path[i].borrow().clone());
        if path[i].borrow().broken {
            paths.push(vec![path[i].borrow().clone()]);
        }
    }
    let mut result: String = "// Generated by Pathy\n\n".into();
    // TODO: set initial pose
    let x = path[0].borrow().pos.borrow().x;
    let y = path[0].borrow().pos.borrow().y;
    let heading = f32::atan2(
        path[0].borrow().cp2.borrow().y - y,
        path[0].borrow().cp2.borrow().x - x,
    ) * (180.0 / std::f32::consts::PI);
    result.push_str(
        format!(
            "wolf.setPose({{{}_in, {}_in, {}_deg}});\n\n",
            format_num(x, 3),
            format_num(y, 3),
            format_num(heading, 1),
        )
        .as_str(),
    );
    for i in 0..paths.len() {
        let name = format!("path{}", i);
        let code = generate_single(&paths[i], step, name);
        result.push_str(format!("{code}\n").as_str());
        let heading = f32::atan2(
            paths[i].last().unwrap().cp2.borrow().y - paths[i].last().unwrap().pos.borrow().y,
            paths[i].last().unwrap().cp2.borrow().x - paths[i].last().unwrap().pos.borrow().x,
        ) * (180.0 / std::f32::consts::PI);
        if i < paths.len() - 1 {
            result.push_str(
                format!("wolf.turnToHeading({}_deg);\n\n", format_num(heading, 1)).as_str(),
            );
        }
    }
    result
}

/// Generates path code from a single Bezier path.
pub fn generate_single(path: &[BezPoint], step: f32, name: String) -> String {
    if path.len() < 2 {
        return format!("std::vector<wolflib::Moment> {name} = wolf.solve({{}}, {step});");
    }
    let mut result: String = format!("std::vector<wolflib::Moment> {name} = wolf.solve({{\n");
    for idx in 0..path.len() - 1 {
        let p1 = &path[idx];
        let p2 = &path[idx + 1];
        result.push_str(
            format!(
                "    {{{{{}_in, {}_in}}, {{{}_in, {}_in}}, {{{}_in, {}_in}}, {{{}_in, {}_in}}}}",
                format_num(p1.pos.borrow().x, 3),
                format_num(p1.pos.borrow().y, 3),
                format_num(p1.cp2.borrow().x, 3),
                format_num(p1.cp2.borrow().y, 3),
                format_num(p2.cp1.borrow().x, 3),
                format_num(p2.cp1.borrow().y, 3),
                format_num(p2.pos.borrow().x, 3),
                format_num(p2.pos.borrow().y, 3)
            )
            .as_str(),
        );
        if idx < path.len() - 2 {
            result.push_str(",\n");
        }
    }
    result.push_str(format!("}}, {step});").as_str());
    result
}

use wasm_bindgen::convert::IntoWasmAbi;

use crate::bezier::BezPoint;
use std::{cell::RefCell, rc::Rc};

/// Generates path code from a path.
pub fn generate(path: &[Rc<RefCell<BezPoint>>], step: f32) -> String {
    if path.len() < 2 {
        return "// Create two points to get started".into();
    }
    // Group into unbroken paths
    let mut paths: Vec<Vec<BezPoint>> = Vec::new();
    paths.push(Vec::new());
    for i in 0..path.len() {
        paths.last_mut().unwrap().push(path[i].borrow().clone());
        if path[i].borrow().broken {
            paths.push(vec![path[i].borrow().clone()]);
        }
    }
    let mut result: String = "// Generated by Pathy\n\n".into();
    // TODO: set initial pose
    for i in 0..paths.len() {
        let name = format!("path{}", i);
        let code = generate_single(&paths[i], step, name);
        result.push_str(format!("{code}\n").as_str());
        let heading = f32::atan2(
            paths[i].last().unwrap().cp2.borrow().y - paths[i].last().unwrap().pos.borrow().y,
            paths[i].last().unwrap().cp2.borrow().x - paths[i].last().unwrap().pos.borrow().x,
        ) * (180.0 / std::f32::consts::PI);
        result.push_str(format!("wolf.turnToHeading({heading:.1}_deg);\n\n").as_str());
    }
    result
}

/// Generates path code from a single Bezier path.
pub fn generate_single(path: &[BezPoint], step: f32, name: String) -> String {
    if path.len() < 2 {
        return format!("std::vector<wolflib::Moment> {name} = wolf.solve({{}}, {step});");
    }
    let mut result: String = format!("std::vector<wolflib::Moment> {name} = wolf.solve({{\n");
    for idx in 0..path.len() - 1 {
        let p1 = &path[idx];
        let p2 = &path[idx + 1];
        result.push_str(
            format!(
                "    {{{{{:.3}_in, {:.3}_in}}, {{{:.3}_in, {:.3}_in}}, {{{:.3}_in, {:.3}_in}}, {{{:.3}_in, {:.3}_in}}}}",
                p1.pos.borrow().x,
                p1.pos.borrow().y,
                p1.cp2.borrow().x,
                p1.cp2.borrow().y,
                p2.cp1.borrow().x,
                p2.cp1.borrow().y,
                p2.pos.borrow().x,
                p2.pos.borrow().y
            )
            .as_str(),
        );
        if idx < path.len() - 2 {
            result.push_str(",\n");
        }
    }
    result.push_str(format!("}}, {step});").as_str());
    result
}
